/**
 * Возвращает значение элемента массива по указанному индексу.
 *
 * Алгоритм:
 * 1. Возвращает элемент массива по индексу.
 *
 * @param {Array} arr - массив элементов
 * @param {number} index - индекс элемента
 * @return {*} значение элемента массива по указанному индексу
 */
export function getValueByIndex(arr, index) {
  throw new Error('method getValueByIndex is not implemented yet');
}

/**
 * Подсчитывает количество итераций, необходимых для уменьшения числа n до 1,
 * деля его на 2 на каждой итерации.
 *
 * Алгоритм:
 * 1. Инициализировать переменную `count` значением `0`.
 * 2. Начать цикл, пока `n` больше 1.
 * 3. На каждой итерации:
 *    1. Делить `n` на 2.
 *    2. Увеличивать `count` на 1.
 * 4. Вернуть `count`.
 *
 * @param {number} n - начальное число
 * @return {number} количество итераций
 */
export function calcLogarithm(n) {
  throw Error('method calcLogarithm is not implemented yet');
}

/**
 * Вычисляет факториал числа n.
 * Формула: n! = n * (n-1) * (n-2) * ... * 1
 *
 * Алгоритм:
 * 1. Проверить, что число неотрицательное.
 * 2. Если число отрицательное:
 *    1. Вернуть сообщение об ошибке.
 * 3. Если число равно 0 или 1:
 *    1. Вернуть 1.
 * 4. Инициализировать переменную `result` значением `1`.
 * 5. Начать цикл от 2 до n.
 * 6. Для каждого числа в цикле:
 *    1. Умножить `result` на текущее число.
 * 7. Вернуть `result`.
 *
 * @param {number} n - число для вычисления факториала
 * @return {number|string} факториал числа или сообщение об ошибке
 */
export function factorial(n) {
  throw Error('method factorial is not implemented yet');
}

/**
 * Вычисляет n-е число Фибоначчи.
 * Формула: F(n) = F(n-1) + F(n-2), где F(0) = 0 и F(1) = 1
 *
 * Алгоритм:
 * 1. Проверить, что число неотрицательное.
 * 2. Если число отрицательное:
 *    1. Вернуть сообщение об ошибке.
 * 3. Если число равно 0 или 1:
 *    1. Вернуть само число.
 * 4. Инициализировать переменные `prev` и `current` значениями 0 и 1 соответственно.
 * 5. Начать цикл от 2 до n.
 * 6. Для каждого числа в цикле:
 *    1. Вычислить следующее число Фибоначчи как сумму `prev` и `current`.
 *    2. Обновить `prev` и `current`.
 * 7. Вернуть `current`.
 *
 * @param {number} n - индекс числа Фибоначчи
 * @return {number|string} n-е число Фибоначчи или сообщение об ошибке
 */
export function fibonacci(n) {
  throw Error('method fibonacci is not implemented yet');
}

/**
 * Сортирует массив методом пузырька.
 *
 * Алгоритм:
 * 1. Начать внешний цикл по элементам массива.
 * 2. Для каждого элемента:
 *    1. Начать внутренний цикл по элементам массива.
 *    2. Сравнивать соседние элементы.
 *    3. Если текущий элемент больше следующего, поменять их местами.
 * 3. Вернуть отсортированный массив.
 *
 * @param {Array<number>} arr - массив чисел
 * @return {Array<number>} отсортированный массив
 */
export function bubbleSort(arr) {
  throw Error('method bubbleSort is not implemented yet');
}

/**
 * Сортирует массив методом вставок.
 *
 * Алгоритм:
 * 1. Начать цикл со второго элемента массива.
 * 2. Для каждого элемента:
 *    1. Сохранить текущий элемент.
 *    2. Начать цикл с конца отсортированной части массива.
 *    3. Сдвигать элементы, которые больше текущего, вправо.
 *    4. Вставить текущий элемент на его место.
 * 3. Вернуть отсортированный массив.
 *
 * @param {Array<number>} arr - массив чисел
 * @return {Array<number>} отсортированный массив
 */
export function insertionSort(arr) {
  throw Error('method insertionSort is not implemented yet');
}

/**
 * Подсчитывает количество уникальных перестановок элементов массива.
 *
 * Алгоритм:
 * 1. Инициализировать переменную `count` значением `0`.
 * 2. Начать цикл по элементам массива.
 * 3. Для каждого элемента:
 *    1. Начать вложенный цикл по элементам массива.
 *    2. Пропустить итерации, если индексы совпадают.
 *    3. Увеличить `count` на 1 для каждой уникальной перестановки.
 * 4. Вернуть `count`.
 *
 * @return {number} количество уникальных перестановок
 */
export function permutation() {
  throw Error('method permutation is not implemented yet');
}

